package com.atom.compiler.apt.aap

import com.atom.compiler.apt.ext.createFile
import com.atom.module.annotation.aap.AapAutoClass
import com.atom.module.annotation.aap.AapImplEntry
import com.squareup.kotlinpoet.*
import org.jetbrains.annotations.TestOnly
import java.io.IOException
import java.util.*
import javax.lang.model.element.Modifier

class AapMetas(private val aapContext: AapContext) {

    private val aapPacketName = AapOptions.AAP_PACKET
    private val aapModuleName: String = aapContext.moduleName

    fun createFile(apis: Set<AapMeta>): TypeSpec.Builder {
        // create class builder
        val classBuilder = TypeSpec.classBuilder(ClassName(aapPacketName, aapModuleName)).apply {
            modifiers.add(KModifier.PUBLIC)
        }
        // add builder super class
        classBuilder.superclass(ClassName.bestGuess(AapImplEntry::class.qualifiedName!!))

        val formatDateValue: String = aapContext.dateFormat.format(Date())
        // 代码创建 文档
        classBuilder.addKdoc(
            CodeBlock.builder()
                .add("<p>This is a class automatically generated by API annotation processor.</p>")
                .add("\n")
                .add("@date ").add(formatDateValue)
                .add("\n")
                .build()
        )
        classBuilder.addAnnotation(
            AnnotationSpec.builder(AapAutoClass::class.java)
                .addMember("value = [%S]", AapProcessor::class.java.simpleName)
                .addMember("data = %S", formatDateValue)
                .build()
        )
        classBuilder.addAnnotation(
            AnnotationSpec.builder(SuppressWarnings::class.java)
                .addMember("value = [%S]", "all")
                .build()
        )
        classBuilder.addFunction(FunSpec.constructorBuilder().apply {
            this.modifiers.add(KModifier.PUBLIC)
            for (api in apis) {
                val isHasApi: Boolean = aapContext.classSet.contains(api.apiQualifiedName)
                if (isHasApi) {
                    continue
                } else {
                    aapContext.classSet.add(api.apiQualifiedName)
                }
                val singleList: MutableList<SingleImpl> = ArrayList()
                getImplNames(api, apis, singleList)
                for (impl in singleList) {
                    println("  >>>>>>  $impl")
                    this.addStatement(
                        "add( %S , %T::class.java , %T::class.java , ${impl.version})" ,
                        impl.name ,impl.apiClass ,impl.implClass ,
                    )
                }
            }
        }.build())
        return classBuilder
    }

    fun writeFile(classBuilder: TypeSpec.Builder) {
        val builder = FileSpec.get(aapPacketName, classBuilder.build())
        try {
            builder.writeTo(aapContext.context.filer)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    @TestOnly
    internal fun writeFile(classBuilder: TypeSpec.Builder, path: String) {
        val builder = FileSpec.get(aapPacketName, classBuilder.build())
        try {
            builder.writeTo(path.createFile())
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun getImplNames(
        api: AapMeta,
        impls: Collection<AapMeta>,
        result: MutableList<SingleImpl>
    ) {
        val apiClassName = ClassName.bestGuess(api.apiQualifiedName)
        for (metaApi in impls) {
            if (!metaApi.isApiImpl(api.apiQualifiedName)) {
                continue
            }
            result.add(
                SingleImpl(
                    apiClassName,
                    ClassName.bestGuess(metaApi.implQualifiedName),
                    metaApi.implName,
                    metaApi.implVersion
                )
            )
        }
    }

    internal data class SingleImpl(
        val apiClass: ClassName,
        val implClass: ClassName,
        val name: String,
        val version: Long
    )
}