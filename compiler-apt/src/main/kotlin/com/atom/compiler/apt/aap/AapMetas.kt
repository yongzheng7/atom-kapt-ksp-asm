package com.atom.compiler.apt.aap

import com.atom.module.annotation.aap.AapAutoClass
import com.atom.module.annotation.aap.AapImplEntry
import com.squareup.kotlinpoet.*
import java.io.IOException
import java.util.*

class AapMetas(private val aapContext: AapContext) {

    private val aapPacketName = AapOptions.AAP_PACKET
    private val aapModuleName: String = aapContext.moduleName
    private val classBuilder: TypeSpec.Builder =
        TypeSpec.classBuilder(ClassName(aapPacketName, aapModuleName)).apply {
            modifiers.add(KModifier.PUBLIC)
        }

    fun addMetasCode(impls: Set<AapMeta>): AapMetas {
        // add builder super class
        classBuilder.superclass(ClassName.bestGuess(AapImplEntry::class.qualifiedName!!))
        val formatDateValue: String = aapContext.dateFormat.format(Date())
        // 代码创建 文档
        classBuilder.addKdoc(
            CodeBlock.builder()
                .add("<p>This is a class automatically generated by API annotation processor.</p>")
                .add("\n")
                .add("@date ").add(formatDateValue)
                .add("\n")
                .build()
        )
        classBuilder.addAnnotation(
            AnnotationSpec.builder(AapAutoClass::class.java)
                .addMember("value = [%S]", AapProcessor::class.java.simpleName)
                .addMember("data = %S", formatDateValue)
                .build()
        )
        classBuilder.addAnnotation(
            AnnotationSpec.builder(SuppressWarnings::class.java)
                .addMember("value = [%S]", "all")
                .build()
        )
        classBuilder.addFunction(FunSpec.constructorBuilder().apply {
            this.modifiers.add(KModifier.PUBLIC)
            this.callSuperConstructor()
            for (api in impls) {
                if (aapContext.classSet.contains(api.apiQualifiedName)) {
                    continue
                } else {
                    aapContext.classSet.add(api.apiQualifiedName)
                }
                for (impl in getImplNames(api, impls)) {
                    this.addStatement(
                        "add( %S , %T::class.java , %T::class.java , ${impl.version})",
                        impl.name, impl.apiClass, impl.implClass,
                    )
                }
            }
        }.build())
        return this;
    }

    fun assembleCode() {
        val builder = FileSpec.get(aapPacketName, classBuilder.build())
        try {
            builder.writeTo(aapContext.context.filer)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun getImplNames(
        api: AapMeta,
        impls: Collection<AapMeta>,
    ): List<SingleImpl> {
        val result: MutableList<SingleImpl> = mutableListOf()
        val apiClassName = api.apiTypeElement.asClassName()
        for (metaApi in impls) {
            if (api.apiTypeElement != metaApi.apiTypeElement) {
                continue
            }
            result.add(
                SingleImpl(
                    apiClassName,
                    metaApi.implTypeElement.asClassName(),
                    metaApi.implName,
                    metaApi.implVersion
                )
            )
        }
        return result
    }

    internal data class SingleImpl(
        val apiClass: ClassName,
        val implClass: ClassName,
        val name: String,
        val version: Long
    )
}